/* 
 * This implements a chained call for used processor
 */
var q=require("q");
var _=require("lodash");
var logger=require("./log")("ProcessorChain");
var Chain = function(imageInfoObj,env){
    this.processors=[];
    this.env = env;//store configures for processor
    this.originalInfo=imageInfoObj;
};
Chain.prototype.run = function(){
  return  _.reduce(this.processors,function(promise,processor){
      logger.debug("Run processor");
      return promise.then(processor)  ;
    },q(this.originalInfo));
};
Chain.prototype.add = function(processors){
    var that = this;
    _(processors).forEach(function(processor){
        
       that.processors.push(that.wrapToFunction(processor));
    });
};
Chain.prototype.wrapToFunction = function(processorClasses){
    var that = this;
  return function(info){
      //info object is used to store result generated by previous processor
      var processor = new processorClasses();
      return processor.process(info,that.env);
  };  
};
module.exports=function(imageInfoObj,processorClasses,env){
    //should create chain at least
    var chain = new Chain(imageInfoObj,env);
    chain.add(processorClasses);
    return chain;
};


